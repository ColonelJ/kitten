/*
 * tictactoe.ktn
 *
 * Contributed by @strager <https://github.com/strager/>
 *
 * Modified by Jon Purdy <https://github.com/evincarofautumn/>
 *
 */

def ; ([a] a -> [a]): append

def show_board_cell (Char -> Char):
  id

def cell_number_to_index (Int -> Int):
  8 swap -

def show_board_cell_at ([Char] Int -> Char):
  cell_number_to_index get
  show_board_cell

def show_board_row ([Char] Int -> [Char]):
  -> row_index
  -> b
  row_index 3 * -> i
  []
  ' ';  b 0 i + show_board_cell_at;
  '|';  b 1 i + show_board_cell_at;
  '|';  b 2 i + show_board_cell_at;

def show_board ([Char] -> [Char]):
  -> b
  []
  "   A B C\n";
  "1 ";  b 0 show_board_row;  "\n";
  "  --+-+--\n";
  "2 ";  b 1 show_board_row;  "\n";
  "  --+-+--\n";
  "3 ";  b 2 show_board_row;  "\n";
  concat

def print_board ([Char] =>):
  show_board print

def new_board (-> [Char]):
  [ ' ', ' ', ' '
  , ' ', ' ', ' '
  , ' ', ' ', ' '
  ]

def read_x (Char -> Int):
  -> c
  if "aA" c elemc then: 0
  else if "bB" c elemc then: 1
  else if "cC" c elemc then: 2
  else: -1

def read_y (Char -> Int):
  -> c
  if "1!" c elemc then: 0
  else if "2@" c elemc then: 1
  else if "3#" c elemc then: 2
  else: -1

def read_xy_(Char Char -> Int Int Bool):
  read_y -> y
  read_x -> x
  if x 0 >=  y 0 >=  && then:
    x y true
  else:
    0 0 false

def read_xy (Char Char -> Int Int Bool):
  -> y
  -> x
  x y read_xy_
  -> success
  -> yi
  -> xi
  if success then:
    xi yi true
  else:
    y x read_xy_

def read_move_line ([Char] -> Int Int Bool):
  -> chars
  if chars length 2 = then:
    chars 1 get
    chars 0 get
    read_xy
  else:
    0 0 false

def xy_to_cell_number (Int Int -> Int):
  -> x
  -> y
  y 3 *
  x +

def edit_board ([Char] Int Char -> [Char]):
  -> c
  -> i
  c
  i cell_number_to_index
  set

def ask_turn ([Char] Char => [Char]):
  -> player
  -> board

  board print_board

  "It is " player append "'s turn. Choose your move: " cat
  print

  getLine -> input
  input read_move_line
  -> parsed -> x -> y

  if parsed then:
    board
    x y xy_to_cell_number
    player edit_board
  else if input "q" eqcv then:
    0 exit board
  else:
    "I didn't understand that. Type e.g. \"a3\" to "
    "move in the bottom-left cell. Type \"q\" to exit.\n" cat
    print
    board player ask_turn

def next_player (Char -> Char):
  if 'x' eqc then: 'o'
  else: 'x'

def gets ([a] [Int] -> [a]):
  -> indices
  -> xs
  indices { xs swap get } map

def check_sets (-> [[Int]]):
  []
  // Rows
  [0, 1, 2];  [3, 4, 5];  [6, 7, 8];
  // Columns
  [0, 3, 6];  [1, 4, 7];  [2, 5, 8];
  // Diagonals
  [0, 4, 8];  [2, 4, 6];

// ' ', 'x', or 'o'
def get_check_set_winner ([Char] [Int] -> Char):
  gets -> players
  if players { 'x' eqc } all then:
    'x'
  else if players { 'o' eqc } all then:
    'o'
  else:
    ' '

// ' ', 'x', 'o', or '*'
def get_winner ([Char] -> Char):
  -> board

  board { ' ' eqc } filter empty
  -> filled

  if filled then:
    '*'
  else:
    check_sets
    { board swap get_check_set_winner } map
    { ' ' nec } filter
    -> winners

    if winners empty then:
      ' '
    else if winners { 'x' eqc } all then:
      'x'
    else if winners { 'o' eqc } all then:
      'o'
    else:
      '*'

def game_loop ([Char] Char => [Char] Char):
  -> player
  -> board

  board get_winner -> winner
  if "xo*" winner elemc then:
    board winner
  else:
    board player ask_turn
    player next_player game_loop

def game (=>):
  new_board 'x' game_loop
  -> winner
  -> final_board

  newline

  if winner '*' eqc then:
    "It's a tie!\n" print
  else:
    " wins!\n" winner prepend print

  final_board print_board

def loop ((=> Bool) =>):
  -> f
  if f call01 then:
    f loop
  else:
    pass

def prompt_play_another (=> Bool):
  "Play another game? [yN] " print
  getLine -> input

  if input { "yY" swap elemc } any then:
    newline
    true
  else if input { "nN" swap elemc } any then:
    newline
    false
  else if input empty then:
    newline
    false
  else:
    prompt_play_another

def main (=>):
  { game prompt_play_another } loop

main
