// Whether all elements of a vector satisfy a predicate.
decl all ([a] (a -> Bool) -> Bool)
def all:
  map and

// Appends a value to the end of a vector.
decl append ([a] a -> [a])
def append:
  vector cat

// Concatenates a vector of vectors.
decl concat ([[a]] -> [a])
def concat:
  [] \cat fold

decl double (a b -> (a, b))
def double:
  -> { a b }
  (a, b)

// Filters a vector by a predicate.
decl filter ([a] (a -> Bool) -> [a])
def filter:
  -> { v f }
  if v empty then:
    v
  else if v head f apply11 then:
    v tail f filter
    v head prepend
  else:
    v tail f filter

decl first ((a & b) -> a)
def first:
  __first

// Flips the elements of a double.
decl flip ((a, b) -> (b, a))
def flip:
  -> d
  d first -> a
  d second -> b
  (b, a)

// Folds elements of a vector right-associatively.
decl foldr ([a] b (a b -> b) -> b)
def foldr:
  -> { xs z k }
  if xs empty then:
    z
  else:
    xs head
    xs tail z k foldr
    k apply21

// Folds elements of a vector left-associatively.
decl fold ([b] a (a b -> a) -> a)
def fold:
  -> { xs z k }
  if xs empty then:
    z
  else:
    xs tail
    z xs head k apply21
    k fold

decl fourth ((a & b & c & d & e) -> d)
def fourth:
  rest rest rest first

// Gets a value from a 2D vector.
decl get2 ([[a]] Int Int -> a)
def get2:
  -> { i j }
  i get j get

// Gets the first element of a vector.
decl head ([a] -> a)
def head:
  __head

// Iterates a function on a value until a predicate holds.
decl until (a (a -> a) (a -> Bool) -> a)
def until:
  -> { x f p }
  if x p apply11 then:
    x
  else:
    x f apply11
    f p until

// Keeps the first n elements of a vector, tossing the rest.
decl keep ([a] Int -> [a])
def keep:
  -> { xs n }
  if n 0 <=  xs empty  || then:
    []
  else:
    xs tail n-- keep
    xs head prepend

// Lifts a function on values to a function on vectors.
decl map ([a] (a -> b) -> [b])
def map:
  -> { xs f }
  if xs empty then:
    []
  else:
    xs tail f map
    xs head f apply11
    prepend

// Maps a function over a value for each integer in a range.
decl mapRange (a (a Int -> a) Int Int -> a)
def mapRange:
  -> { value function start end }
  if start end <= then:
    value start function apply21
    function start++ end mapRange
  else:
    value

// Maps a function over an element of a vector.
decl modify ([a] (a -> a) Int -> [a])
def modify:
  -> { vec function offset }
  vec offset get function apply11 -> value
  vec value offset set

// Maps a function over part of a vector.
decl mapFrom ([a] (a -> a) Int -> [a])
def mapFrom:
  -> { vec function offset }
  if vec empty  offset vec length >=  || then:
    vec
  else:
    vec function offset modify
    function offset++ mapFrom

// Maps an impure function over each element of a vector.
decl each ([a] (a ->) ->)
def each:
  -> f
  { dup f apply10 } map
  drop

// Produces a vector with some number of copies of a value.
decl replicate (a Int -> [a])
def replicate:
  -> { value count }
  if count 0 <= then:
    []
  else:
    value count-- replicate
    value prepend

decl rest ((a & b) -> b)
def rest:
  __rest

decl reverse ([a] -> [a])
def reverse:
  -> xs
  if xs empty then:
    []
  else:
    xs init reverse
    xs last prepend

decl second ((a & b & c) -> b)
def second:
  rest first

// Sets a value in a 2D vector.
decl set2 ([[a]] a Int Int -> [[a]])
def set2:
  -> { x i j }
  { x j set } i modify

// Splits a vector into two parts at the given index.
decl split_at ([a] Int -> [a] [a])
def split_at:
  -> { xs n }
  xs n toss
  xs n keep

decl third ((a & b & c & d) -> c)
def third:
  rest rest first

// Tosses the first n elements of a vector, keeping the rest.
decl toss ([a] Int -> [a])
def toss:
  -> { xs n }
  if n 0 <=  xs empty  || then:
    xs
  else:
    xs tail n-- toss

// Logical NOT.
decl ! (Bool -> Bool)
def ! :
  __not_bool

// Integer inequality.
decl != (Int Int -> Bool)
def != :
  __ne_int

// Floating-point inequality.
decl !=. (Float Float -> Bool)
def !=. :
  __ne_float

// Integer modulus.
decl % (Int Int -> Int)
def % :
  __mod_int

// Floating-point modulus.
decl %. (Float Float -> Float)
def %. :
  __mod_float

// Bitwise AND.
decl & (Int Int -> Int)
def & :
  __and_int

// Logical AND.
decl && (Bool Bool -> Bool)
def && :
  __and_bool

// Integer multiplication.
decl * (Int Int -> Int)
def * :
  __mul_int

// Floating-point multiplication.
decl *. (Float Float -> Float)
def *. :
  __mul_float

// Integer addition.
decl + (Int Int -> Int)
def + :
  __add_int

// Integer increment.
decl ++ (Int -> Int)
def ++ :
  __inc_int

// Floating-point increment.
decl ++. (Float -> Float)
def ++. :
  __inc_float

// Floating-point addition.
decl +. (Float Float -> Float)
def +. :
  __add_float

// Integer subtraction.
decl - (Int Int -> Int)
def - :
  __sub_int

// Integer decrement.
decl -- (Int -> Int)
def -- :
  __dec_int

// Floating-point decrement.
decl --. (Float -> Float)
def --. :
  __dec_float

// Floating-point subtraction.
decl -. (Float Float -> Float)
def -. :
  __sub_float

// Integer division.
decl / (Int Int -> Int)
def / :
  __div_int

// Floating-point division.
decl /. (Float Float -> Float)
def /. :
  __div_float

// Integer less than.
decl < (Int Int -> Bool)
def < :
  __lt_int

// Floating-point less than.
decl <. (Float Float -> Bool)
def <. :
  __lt_float

// Integer less than or equal.
decl <= (Int Int -> Bool)
def <= :
  __le_int

// Floating-point less than or equal.
decl <=. (Float Float -> Bool)
def <=. :
  __le_float

// Integer equality.
decl = (Int Int -> Bool)
def = :
  __eq_int

// Floating-point equality.
decl =. (Float Float -> Bool)
def =. :
  __eq_float

// Integer greater than.
decl > (Int Int -> Bool)
def > :
  __gt_int

// Floating-point greater than.
decl >. (Float Float -> Bool)
def >. :
  __gt_float

// Integer greater than or equal.
decl >= (Int Int -> Bool)
def >= :
  __ge_int

// Floating-point greater than or equal.
decl >=. (Float Float -> Bool)
def >=. :
  __ge_float

// Bitwise XOR.
decl ^ (Int Int -> Int)
def ^ :
  __xor_int

// Boolean XOR.
decl ^^ (Bool Bool -> Bool)
def ^^ :
  __xor_bool

// Whether all elements of a vector are true.
decl and ([Bool] -> Bool)
def and:
  true \&& fold

// Whether any element of a vector satisfies a predicate.
decl any ([a] (a -> Bool) -> Bool)
def any:
  map or

// Applies a nullary function with one result.
decl apply01 ((-> a) -> a)
def apply01:
  __apply01

// Applies a unary function with no results.
decl apply10 (a (a ->) ->)
def apply10:
  __apply10

// Applies a unary function with one result.
decl apply11 (a (a -> b) -> b)
def apply11:
  __apply11

// Applies a binary function with one result.
decl apply21 (a b (a b -> c) -> c)
def apply21:
  __apply21

// Concatenates two vectors.
decl cat ([a] [a] -> [a])
def cat :
  __add_vector

// Composes two unary functions with one result.
decl compose ((a -> b) (b -> c) -> (a -> c))
def compose:
  -> { f g }
  { f apply11 g apply11 }

// Wraps a value in a function.
decl const (a -> (b -> a))
def const:
  -> x
  { drop x }

// Drops a value.
decl drop (a ->)
def drop:
  __drop

// Duplicates a value.
decl dup (a -> a a)
def dup:
  __dup

// Whether a character is present in a string.
decl elemc ([Char] Char -> Bool)
def elemc:
  -> x
  { x eqc } any

// Whether an integer is present in an integer vector.
decl elemi ([Int] Int -> Bool)
def elemi:
  -> x
  { x = } any

// Whether a vector is empty.
decl empty ([a] -> Bool)
def empty:
  __empty

// Character equality.
decl eqc (Char Char -> Bool)
def eqc :
  __eq_char

// String equality.
decl eqcv ([Char] [Char] -> Bool)
def eqcv:
  \eqc eqv

// Integer vector equality.
decl eqiv ([Int] [Int] -> Bool)
def eqiv:
  \= eqv

decl equ (() () -> Bool)
def equ:
  drop drop true

// Vector equality according to a predicate.
decl eqv ([a] [a] (a a -> Bool) -> Bool)
def eqv:
  -> { xs ys eq }
  if xs empty ys empty && then:
    true
  else if xs head ys head eq apply21 then:
    xs tail ys tail eq eqv
  else:
    false

// Whether a floating-point number is even.
decl evenf (Float -> Bool)
def evenf:
  2.0 %. 0.0 =.

// Whether an integer is even.
decl eveni (Int -> Bool)
def eveni:
  2 __mod_int 0 __eq_int

// Exits the program with a given status code.
decl exit (Int ->)
def exit:
  __exit

// Character greater than or equal.
decl gec (Char Char -> Bool)
def gec :
  __ge_char

// Gets an element of a vector.
decl get ([a] Int -> a)
def get:
  __get

// Reads a line from standard input.
decl getLine (-> [Char])
def getLine:
  stdin __get_line

// Vector greater than or equal.
decl gev ([a] [a] (a a -> Bool) -> Bool)

// Character greater than.
decl gtc (Char Char -> Bool)
def gtc :
  __gt_char

// Vector greater than.
decl gtv ([a] [a] (a a -> Bool) -> Bool)

// Closes a handle.
decl handleClose (Handle ->)
def handleClose:
  __close

// Reads a line from a handle.
decl handleGetLine (Handle -> [Char])
def handleGetLine:
  __get_line

// Writes a string to a handle.
decl handlePrint ([Char] Handle ->)
def handlePrint:
  __print

// The identity function.
decl id (a -> a)
def id:
  -> x
  x

// Removes the last element of a vector.
decl init ([a] -> [a])
def init:
  __init

// Joins a vector with a separator.
decl join ([[a]] [a] -> [a])
def join:
  intersperse concat

// Intersperses a value between the values of a vector.
decl intersperse ([a] a -> [a])
def intersperse:
  -> { xs sep }
  if xs empty then:
    []
  else:
    xs tail sep prependToAll
    xs head prepend

// Gets the last element of a vector.
decl last ([a] -> a)
def last:
  __last

// Character less than or equal.
decl lec (Char Char -> Bool)
def lec :
  __le_char

// Gets the length of a vector.
decl length ([a] -> Int)
def length:
  __length

// Vector less than or equal.
decl lev ([a] [a] (a a -> Bool) -> Bool)

// Character less than.
decl ltc (Char Char -> Bool)
def ltc :
  __lt_char

// Vector less than.
decl ltv ([a] [a] (a a -> Bool) -> Bool)

// Maps a function over a vector and concatenates the results.
decl mapConcat ([a] (a -> [b]) -> [b])
def mapConcat:
  map concat

// The maximum of two integers.
decl max2 (Int Int -> Int)
def max2:
  -> { a b }
  if a b > then: a else: b

// The maximum of three integers.
decl max3 (Int Int Int -> Int)
def max3:
  max2 max2

// The minimum of two integers.
decl min2 (Int Int -> Int)
def min2:
  -> { a b }
  if a b < then: a else: b

// The minimum of three integers.
decl min3 (Int Int Int -> Int)
def min3:
  min2 min2

// Character inequality.
decl nec (Char Char -> Bool)
def nec :
  __ne_char

// Floating-point negation.
decl negf (Float -> Float)
def negf:
  __neg_float

// Integer negation.
decl negi (Int -> Int)
def negi:
  __neg_int

// Vector inequality.
decl nev ([a] [a] (a a -> Bool) -> Bool)

// Prints a newline to standard output.
decl newline (->)
def newline:
  "\n" print

// Whether a floating-point number is odd.
decl oddf (Float -> Bool)
def oddf:
  evenf !

// Whether an integer is odd.
decl oddi (Int -> Bool)
def oddi:
  eveni !

// Opens a file for input.
decl openInput ([Char] -> Handle)
def openInput:
  __open_in

// Opens a file for output.
decl openOutput ([Char] -> Handle)
def openOutput:
  __open_out

// Whether any element of a vector is true.
decl or ([Bool] -> Bool)
def or:
  false \|| fold

decl pair (a b -> (a & b))
def pair:
  __pair

// No-op.
decl pass (->)
def pass {}

// Prepends a value to the head of a vector.
decl prepend ([a] a -> [a])
def prepend:
  -> { xs x }
  x vector xs cat

decl prependToAll ([a] a -> [a])
def prependToAll:
  -> { xs sep }
  if xs empty then:
    []
  else:
    xs tail sep prependToAll
    xs head prepend
    sep prepend

// Prints a string to standard output.
decl print ([Char] ->)
def print:
  stdout __print

// Prints a Boolean.
decl printb (Bool ->)
def printb:
  showb print

// Prints a Boolean vector.
decl printbv ([Bool] ->)
def printbv:
  showbv print

// Prints a string vector.
decl printcvv ([[Char]] ->)
def printcvv:
  showcvv print

// Prints a floating-point number.
decl printf (Float ->)
def printf:
  showf print

// Prints a floating-point vector.
decl printfv ([Float] ->)
def printfv:
  showfv print

// Prints an integer.
decl printi (Int ->)
def printi:
  showi print

// Prints an integer vector.
decl printiv ([Int] ->)
def printiv:
  showiv print

// The product of a vector of floating-point numbers.
decl productf ([Float] -> Float)
def productf:
  1.0 \*. fold

// The product of a vector of integers.
decl producti ([Int] -> Int)
def producti:
  1 \* fold

// Prints a string followed by a newline.
decl say ([Char] ->)
def say:
  print newline

// Says a Boolean.
decl sayb (Bool ->)
def sayb:
  printb newline

// Says a Boolean vector.
decl saybv ([Bool] ->)
def saybv:
  printbv newline

// Says a string vector.
decl saycvv ([[Char]] ->)
def saycvv:
  printcvv newline

// Says a floating-point number.
decl sayf (Float ->)
def sayf:
  printf newline

// Says a floating-point vector.
decl sayfv ([Float] ->)
def sayfv:
  printfv newline

// Says an integer.
decl sayi (Int ->)
def sayi:
  printi newline

// Says an integer vector.
decl sayiv ([Int] ->)
def sayiv:
  printiv newline

// Sets the value at an index in a vector.
decl set ([a] a Int -> [a])
def set:
  __set

// Shows a Boolean as a string.
decl showb (Bool -> [Char])
def showb:
  if then: "true"
  else: "false"

// Shows a Boolean vector as a string.
decl showbv ([Bool] -> [Char])
def showbv:
  \showb showv

// Shows a string vector as a string.
decl showcvv ([[Char]] -> [Char])
def showcvv:
  \id showv

// Shows a floating-point number as a string.
decl showf (Float -> [Char])
def showf:
  __show_float

// Shows a floating-point vector as a string.
decl showfv ([Float] -> [Char])
def showfv:
  \showf showv

// Shows an integer as a string.
decl showi (Int -> [Char])
def showi:
  __show_int

// Shows an integer vector as a string.
decl showiv ([Int] -> [Char])
def showiv:
  \showi showv

// Shows a vector as a string.
decl showv ([a] (a -> [Char]) -> [Char])
def showv:
  -> { v f }
  "[" v f map ", " join "]" cat cat

// Prints a space to standard output.
decl space (->)
def space:
  " " print

// The standard error handle.
decl stderr (-> Handle)
def stderr:
  __stderr

// The standard input handle.
decl stdin (-> Handle)
def stdin:
  __stdin

// The standard output handle.
decl stdout (-> Handle)
def stdout:
  __stdout

// The sum of a vector of floating-point numbers.
decl sumf ([Float] -> Float)
def sumf:
  0.0 \+. fold

// The sum of a vector of integers.
decl sumi ([Int] -> Int)
def sumi:
  0 \+ fold

// Swaps two values. Useful for changing argument order when
// partially applying a function.
decl swap (a b -> b a)
def swap:
  __swap

// Removes the first element of a vector.
decl tail ([a] -> [a])
def tail:
  __tail

// Join a list of lines into a string.
decl unlines ([[Char]] -> [Char])
def unlines:
  "\n" join

// Wraps a value in a vector.
decl vector (a -> [a])
def vector:
  __vector

// Bitwise OR.
decl | (Int Int -> Int)
def | :
  __or_int

// Logical OR.
decl || (Bool Bool -> Bool)
def || :
  __or_bool

// Bitwise NOT.
decl ~ (Int -> Int)
def ~ :
  __not_int

// Zip two lists together as pairs
decl zip ([a] [b] -> [(a, b)])
def zip:
  \double zipWith

// Zip two lists together with a function
decl zipWith ([a] [b] (a b -> c) -> [c])
def zipWith:
  -> { as bs f }
  if as empty  bs empty  || then:
    []
  else:
    as tail bs tail f zipWith
    as head bs head f apply21 prepend
