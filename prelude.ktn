def absInt (Int -> Int):
  if dup 0 < then: negInt else: id

def absFloat (Float -> Float):
  if dup 0.0 <. then: negFloat else: id

// Whether all elements of a vector satisfy a predicate.
def all ([a] (a -> Bool) -> Bool):
  map and

// Appends a value to the end of a vector.
def append ([a] a -> [a]):
  vector cat

// The Cartesian product of two vectors.
def cartesian ([a] [b] -> [(a, b)]):
  {double} cartesianWith

// The Cartesian product of two vectors with a generalized
// tupling function.
def cartesianWith ([a] [b] (a b -> c) -> [c]):
  -> { xs ys function }
  xs { -> x
    ys { -> y
      [x y function@]
    } mapConcat
  } mapConcat

// Converts a character to an integer code point.
def charToInt (Char -> Int):
  __char_to_int

def choice ((a | b) (a -> c) (b -> c) -> c):
  -> { x l r }
  if x isLeft then:
    x fromLeft l@
  else:
    x fromRight r@

// Concatenates a vector of vectors.
def concat ([[a]] -> [a]):
  [] {cat} foldl

// Constructs a 2-tuple.
def double (a b -> (a, b)):
  -> { a b }
  (a, b)

// Filters a vector by a predicate.
def filter ([a] (a -> Bool) -> [a]):
  -> { v f }
  if v isEmpty then:
    v
  else if v head f@ then:
    v tail f filter
    v head prepend
  else:
    v tail f filter

// Gets the first element of a tuple or pair.
def first ((a & b) -> a):
  __first

// Flips the elements of a double.
def flip ((a, b) -> (b, a)):
  -> pair
  (pair second, pair first)

// Folds elements of a vector right-associatively.
def foldr ([a] b (a b -> b) -> b):
  -> { xs z k }
  if xs isEmpty then:
    z
  else:
    xs head
    xs tail z k foldr
    k@

// Folds elements of a vector left-associatively.
def foldl ([b] a (a b -> a) -> a):
  -> { xs z k }
  if xs isEmpty then:
    z
  else:
    xs tail
    z xs head k@
    k foldl

// Gets the fourth element of a tuple.
def fourth ((a & b & c & d & e) -> d):
  rest rest rest first

def fromLeft (a | b -> a):
  __from_left

def fromRight (a | b -> b):
  __from_right

def fromOption (a? a -> a):
  -> { m z }
  if m isNone then: z else: m fromSome

def fromSome (a? -> a):
  __from_some

def isLeft (a | b -> Bool):
  isRight not

def isNone (a? -> Bool):
  __is_none

def isRight (a | b -> Bool):
  __is_right

def isSome (a? -> Bool):
  isNone not

def left (a -> a | b):
  __left

def none (-> a?):
  __none

def right (b -> a | b):
  __right

def some (a -> a?):
  __some

// Gets a value from a 2D vector.
def ## ([[a]] Int Int -> a):
  -> { i j }
  i# j#

// Gets the first element of a vector.
def head ([a] -> a):
  0#

def headTail ([a] -> a [a]):
  -> xs
  xs head xs tail

// Iterates a function on a value until a predicate holds.
def until (a (a -> a) (a -> Bool) -> a):
  -> { x f p }
  if x p@ then:
    x
  else:
    x f@
    f p until

// Keeps the first n elements of a vector, tossing the rest.
def keep ([a] Int -> [a]):
  -> { xs n }
  if n 0 <=  xs isEmpty  || then:
    []
  else:
    xs tail n-- keep
    xs head prepend

// Lifts a function on values to a function on vectors.
def map ([a] (a -> b) -> [b]):
  -> { xs f }
  if xs isEmpty then:
    []
  else:
    xs tail f map
    xs head f@
    prepend

// Maps a function over a value for each integer in a range.
def mapRange (a (a Int -> a) Int Int -> a):
  -> { value function start end }
  if start end <= then:
    value start function@
    function start++ end mapRange
  else:
    value

// Maps a function over an element of a vector.
def #@ ([a] (a -> a) Int -> [a]):
  -> { vec function offset }
  vec offset# function@ -> value
  vec value offset #!

// Maps a function over part of a vector.
def mapFrom ([a] (a -> a) Int -> [a]):
  -> { vec function offset }
  if vec isEmpty  offset vec length >=  || then:
    vec
  else:
    vec function offset #@
    function offset++ mapFrom

// Maps a procedure over each element of a vector.
def each ([a] (a =>) =>):
  -> { xs f }
  if xs isEmpty then:
    pass
  else:
    xs head f!
    xs tail f each

// Produces a vector with some number of copies of a value.
def replicate (a Int -> [a]):
  -> { value count }
  if count 0 <= then:
    []
  else:
    value count-- replicate
    value prepend

// Gets the second element of a pair or the tail of a tuple.
def rest ((a & b) -> b):
  __rest

// Reverses a vector.
def reverse ([a] -> [a]):
  -> xs
  if xs isEmpty then:
    []
  else:
    xs init reverse
    xs last prepend

// Gets the second element of a tuple.
def second ((a & b & c) -> b):
  rest first

// Sets a value in a 2D vector.
def ##! ([[a]] a Int Int -> [[a]]):
  -> { x i j }
  { x j#! } i#@

// Splits a vector into two parts at the given index.
def splitAt ([a] Int -> [a] [a]):
  -> { xs n }
  xs n keep
  xs n toss

// Gets the third element of a tuple.
def third ((a & b & c & d) -> c):
  rest rest first

// Tosses the first n elements of a vector, keeping the rest.
def toss ([a] Int -> [a]):
  -> { xs n }
  if n 0 <=  xs isEmpty  || then:
    xs
  else:
    xs tail n-- toss

// Logical NOT.
def not (Bool -> Bool):
  __not_bool

// Integer inequality.
def != (Int Int -> Bool):
  __ne_int

// Floating-point inequality.
def !=. (Float Float -> Bool):
  __ne_float

// Integer modulus.
def % (Int Int -> Int):
  __mod_int

// Floating-point modulus.
def %. (Float Float -> Float):
  __mod_float

// Bitwise AND.
def & (Int Int -> Int):
  __and_int

// Logical AND.
def && (Bool Bool -> Bool):
  __and_bool

// Integer multiplication.
def * (Int Int -> Int):
  __mul_int

// Floating-point multiplication.
def *. (Float Float -> Float):
  __mul_float

// Integer addition.
def + (Int Int -> Int):
  __add_int

// Integer increment.
def ++ (Int -> Int):
  1 +

// Floating-point increment.
def ++. (Float -> Float):
  1.0 +.

// Floating-point addition.
def +. (Float Float -> Float):
  __add_float

// Integer subtraction.
def - (Int Int -> Int):
  __sub_int

// Integer decrement.
def -- (Int -> Int):
  1 -

// Floating-point decrement.
def --. (Float -> Float):
  1.0 -.

// Floating-point subtraction.
def -. (Float Float -> Float):
  __sub_float

// Integer division.
def / (Int Int -> Int):
  __div_int

// Floating-point division.
def /. (Float Float -> Float):
  __div_float

// Integer less than.
def < (Int Int -> Bool):
  __lt_int

// Floating-point less than.
def <. (Float Float -> Bool):
  __lt_float

// Integer less than or equal.
def <= (Int Int -> Bool):
  __le_int

// Floating-point less than or equal.
def <=. (Float Float -> Bool):
  __le_float

// Integer equality.
def = (Int Int -> Bool):
  __eq_int

// Floating-point equality.
def =. (Float Float -> Bool):
  __eq_float

// Integer greater than.
def > (Int Int -> Bool):
  __gt_int

// Floating-point greater than.
def >. (Float Float -> Bool):
  __gt_float

// Integer greater than or equal.
def >= (Int Int -> Bool):
  __ge_int

// Floating-point greater than or equal.
def >=. (Float Float -> Bool):
  __ge_float

// Bitwise XOR.
def ^ (Int Int -> Int):
  __xor_int

// Boolean XOR.
def ^^ (Bool Bool -> Bool):
  __xor_bool

// Whether all elements of a vector are true.
def and ([Bool] -> Bool):
  true {&&} foldl

// Whether any element of a vector satisfies a predicate.
def any ([a] (a -> Bool) -> Bool):
  map or

// Concatenates two vectors.
def cat ([a] [a] -> [a]):
  __add_vector

// Composes two unary functions with one result.
def compose ((a -> b) (b -> c) -> (a -> c)):
  -> { f g }
  { f@ g@ }

// Wraps a value in a function.
def const (a -> (b -> a)):
  -> x
  { drop x }

// Drops a value.
def drop (a ->):
  -> x

// Duplicates a value.
def dup (a -> a a):
  -> x
  x x

// Whether a character is present in a string.
def elemChar ([Char] Char -> Bool):
  {eqChar} elem

def elem ([a] a (a a -> Bool) -> Bool):
  -> { xs x f }
  xs { x f@ } any

// Whether an integer is present in an integer vector.
def elemInt ([Int] Int -> Bool):
  {=} elem

// Whether a vector is empty.
def isEmpty ([a] -> Bool):
  length 0 =

// Character equality.
def eqChar (Char Char -> Bool):
  {charToInt} on =

// String equality.
def eqString ([Char] [Char] -> Bool):
  {eqChar} eqVector

def eqUnit (() () -> Bool):
  drop drop true

def eqVector ([a] [a] (a a -> Bool) -> Bool):
  -> { xs ys eq }
  if xs length ys length != then:
    false
  else:
    xs ys eq zipWith and

// Whether a floating-point number is even.
def evenFloat (Float -> Bool):
  2.0 %. 0.0 =.

// Whether an integer is even.
def evenInt (Int -> Bool):
  2 % 0 =

def exit (Int =>):
  __exit

// Character greater than or equal.
def geChar (Char Char -> Bool):
  {charToInt} on >=

// Gets an element of a vector.
def # ([a] Int -> a):
  __get

// Gets multiple elements of a vector.
def getAll ([a] [Int] -> [a]):
  -> indices
  -> xs
  indices { xs swap # } map

// Reads a line from standard input.
def getLine (=> [Char]):
  stdin __get_line

// Character greater than.
def gtChar (Char Char -> Bool):
  {charToInt} on >

// Closes a handle.
def handleClose (Handle =>):
  __close

// Reads a line from a handle.
def handleGetLine (Handle => [Char]):
  __get_line

// Writes a string to a handle.
def handlePrint ([Char] Handle =>):
  __print

// Identity function.
def id (a -> a):
  -> x
  x

// An impure no-op, for casting a function to a procedure.
def impure (=>):
  __impure

// Removes the last element of a vector.
def init ([a] -> [a]):
  __init

// Joins a vector with a separator.
def join ([[a]] [a] -> [a]):
  intersperse concat

// Intersperses a value between the values of a vector.
def intersperse ([a] a -> [a]):
  -> { xs sep }
  if xs isEmpty then:
    []
  else:
    xs tail sep prependToAll
    xs head prepend

// Gets the last element of a vector.
def last ([a] -> a):
  dup  length 1 -  #

// Character less than or equal.
def leChar (Char Char -> Bool):
  {charToInt} on <=

// Gets the length of a vector.
def length ([a] -> Int):
  __length

// Character less than.
def ltChar (Char Char -> Bool):
  {charToInt} on <

// Repeats an action until a condition is false.
def loopWhile ((=> Bool) =>):
  -> f
  if f! then: f loopWhile

// Maps a function over a vector and concatenates the results.
def mapConcat ([a] (a -> [b]) -> [b]):
  map concat

// The maximum of two integers.
def maxInt (Int Int -> Int):
  -> { a b }
  if a b > then: a else: b

// The maximum of three integers.
def maxInt3 (Int Int Int -> Int):
  maxInt maxInt

// The maximum of a vector of integers.
def maxInts ([Int] -> Int):
  {maxInt} foldl1

// The minimum of two integers.
def minInt (Int Int -> Int):
  -> { a b }
  if a b < then: a else: b

// The minimum of three integers.
def minInt3 (Int Int Int -> Int):
  minInt minInt

// The minimum of a vector of integers.
def minInts ([Int] -> Int):
  {minInt} foldl1

// Character inequality.
def neChar (Char Char -> Bool):
  {charToInt} on !=

// Floating-point negation.
def negFloat (Float -> Float):
  __neg_float

// Integer negation.
def negInt (Int -> Int):
  __neg_int

// Writes a newline to standard output.
def newline (=>):
  "\n" print

// Whether a floating-point number is odd.
def oddFloat (Float -> Bool):
  evenFloat not

// Whether an integer is odd.
def oddInt (Int -> Bool):
  evenInt not

// Apply a unary function to two values.
def on (a a (a -> b) -> b b):
  -> { x y f }
  x f@ -> a
  y f@ -> b
  a b

// Opens a file for input.
def openInput ([Char] => Handle):
  __open_in

// Opens a file for output.
def openOutput ([Char] => Handle):
  __open_out

// Whether any element of a vector is true.
def or ([Bool] -> Bool):
  false {||} foldl

// Constructs a pair.
def pair (a b -> (a & b)):
  __pair

// No-op.
def pass (->)
  {}

// The ratio of a circle's circumference to its diameter.
def pi 3.141592653589793

// Prepends a value to the head of a vector.
def prepend ([a] a -> [a]):
  -> { xs x }
  x vector xs cat

def prependToAll ([a] a -> [a]):
  -> { xs sep }
  if xs isEmpty then:
    []
  else:
    xs tail sep prependToAll
    xs head prepend
    sep prepend

// Writes a string to standard output.
def print ([Char] =>):
  stdout __print

// Prints a Boolean.
def printBool (Bool =>):
  showBool print

// Prints a Boolean vector.
def printBools ([Bool] =>):
  showBools print

// Prints a string vector.
def printStrings ([[Char]] =>):
  showStrings print

// Prints a floating-point number.
def printFloat (Float =>):
  showFloat print

// Prints a floating-point vector.
def printFloats ([Float] =>):
  showFloats print

// Prints an integer.
def printInt (Int =>):
  showInt print

// Prints an integer vector.
def printInts ([Int] =>):
  showInts print

// The product of a vector of floating-point numbers.
def productFloats ([Float] -> Float):
  1.0 {*.} foldl

// The product of a vector of integers.
def productInts ([Int] -> Int):
  1 {*} foldl

def prompt ([Char] => [Char]):
  print getLine

// Prints a string followed by a newline.
def say ([Char] =>):
  print newline

// Says a Boolean.
def sayBool (Bool =>):
  printBool newline

// Says a Boolean vector.
def sayBools ([Bool] =>):
  printBools newline

// Says a string vector.
def sayStrings ([[Char]] =>):
  printStrings newline

// Says a floating-point number.
def sayFloat (Float =>):
  printFloat newline

// Says a floating-point vector.
def sayFloats ([Float] =>):
  printFloats newline

// Says an integer.
def sayInt (Int =>):
  printInt newline

// Says an integer vector.
def sayInts ([Int] =>):
  printInts newline

// Sets the value at an index in a vector.
def #! ([a] a Int -> [a]):
  __set

// Shows a Boolean as a string.
def showBool (Bool -> [Char]):
  if then: "true" else: "false"

// Shows a Boolean vector as a string.
def showBools ([Bool] -> [Char]):
  {showBool} showVector

// Shows a string vector as a string.
def showStrings ([[Char]] -> [Char]):
  {id} showVector

// Shows a floating-point number as a string.
def showFloat (Float -> [Char]):
  __show_float

// Shows a floating-point vector as a string.
def showFloats ([Float] -> [Char]):
  {showFloat} showVector

// Shows an integer as a string.
def showInt (Int -> [Char]):
  __show_int

// Shows an integer vector as a string.
def showInts ([Int] -> [Char]):
  {showInt} showVector

// Shows a vector as a string.
def showVector ([a] (a -> [Char]) -> [Char]):
  -> { v f }
  "[" v f map ", " join "]" cat cat

// Prints a space to standard output.
def space (=>):
  " " print

// The standard error handle.
def stderr (-> Handle):
  __stderr

// The standard input handle.
def stdin (-> Handle):
  __stdin

// The standard output handle.
def stdout (-> Handle):
  __stdout

// The sum of a vector of floating-point numbers.
def sumFloats ([Float] -> Float):
  0.0 {+.} foldl

// The sum of a vector of integers.
def sumInts ([Int] -> Int):
  0 {+} foldl

// Swaps two values. Useful for changing argument order when
// partially applying a function.
def swap (a b -> b a):
  -> { a b }
  b a

// Prints a tab character to standard output.
def tab (=>):
  "\t" print

// Removes the first element of a vector.
def tail ([a] -> [a]):
  __tail

// The ratio of a circle's circumference to its radius.
def tau 6.283185307179586

// Transposes the rows and columns of a 2D vector.
def transpose ([[a]] -> [[a]]):
  -> xss
  if xss isEmpty then:
    []
  else if xss head isEmpty then:
    xss tail transpose
  else:
    xss headTail -> { xs xss }
    xs headTail -> { x xs }
    xss {tail} map  xs prepend  transpose
    xss {head} map  x prepend
    prepend

// Joins a vector of lines into a string.
def unlines ([[Char]] -> [Char]):
  "\n" join

// Unsafely calls a unary procedure with one result.
def unsafeCall11 (a (a => b) -> b):
  unsafePurify11@

// Unsafely casts a unary procedure with one result into a
// similarly typed function.
def unsafePurify11 ((a => b) -> (a -> b)):
  __unsafe_purify11

// Wraps a value in a vector.
def vector (a -> [a]):
  __vector

// Bitwise OR.
def | (Int Int -> Int):
  __or_int

// Logical OR.
def || (Bool Bool -> Bool):
  __or_bool

// Bitwise NOT.
def ~ (Int -> Int):
  __not_int

// Zips two lists together as pairs.
def zip ([a] [b] -> [(a, b)]):
  {double} zipWith

// Zips two lists together with a function.
def zipWith ([a] [b] (a b -> c) -> [c]):
  -> { as bs f }
  if as isEmpty  bs isEmpty  || then:
    []
  else:
    as tail bs tail f zipWith
    as head bs head f@ prepend

// Range of integers from start to finish generating
// based on a given next and compare functions
def rangeFor (Int Int (Int -> Int) (Int Int -> Bool) -> [Int]):
  -> { start end next cmp }
  if start end cmp@ then:
    []
  else:
    start next@
      end next cmp rangeFor
    start prepend

// Non-inclusive range
def rangeUntil (Int Int -> [Int]):
  -> { start end }
  if start end < then:
    start end { ++ } { >= } rangeFor
  else:
    start end { -- } { <= } rangeFor

// Inclusive range
def rangeTo (Int Int -> [Int]):
  -> { start end }
  if start end < then:
    start end { ++ } { > } rangeFor
  else:
    start end { -- } { < } rangeFor

// Inclusive range (shorthand)
def .. (Int Int -> [Int]) { rangeTo }

// Non-inclusive range (shorthand)
def ... (Int Int -> [Int]) { rangeUntil }

// Left-leaning vector fold starting from first element
def foldl1 ([a] (a a -> a) -> a):
  -> { xs fn }
  xs tail xs head fn foldl

// Right-leaning vector fold starting from last element
def foldr1 ([a] (a a -> a) -> a):
  -> { xs fn }
  xs init xs last fn foldr

// Scan fold of remaining elements
def scanlRest ([b] a (a b -> a) -> [a]):
  -> { xs z k }
  if xs isEmpty then:
    []
  else:
    z xs head k@ -> q
    xs tail q k scanlRest
    q prepend

// Produce a list of fold-left results
def scanl ([b] a (a b -> a) -> [a]):
  -> { xs z k }
  xs z k scanlRest z prepend

// Produce a list of fold-right results
def scanr ([a] b (a b -> b) -> [b]):
  -> { xs z k }
  if xs isEmpty then:
    [z]
  else:
    xs tail z k scanr dup head
    xs head swap k@
    prepend

// Scan left with vector head as accumulator
def scanl1 ([a] (a a -> a) -> [a]):
  -> { xs k }
  xs tail xs head k scanl

// Scan right with vector last as accumulator
def scanr1 ([a] (a a -> a) -> [a]):
  -> { xs k }
  xs init xs last k scanr
