// Builtin

decl +. (Float Float -> Float)
def +.:
  __add_float

decl + (Int Int -> Int)
def +:
  __add_int

decl +* ([a] [a] -> [a])
def +*:
  __add_vector

decl && (Bool Bool -> Bool)
def &&:
  __and_bool

decl & (Int Int -> Int)
def &:
  __and_int

decl apply01 ((-> a) -> a)
def apply01:
  __apply01

decl apply10 (a (a ->) ->)
def apply10:
  __apply10

decl apply11 (a (a -> b) -> b)
def apply11:
  __apply11

decl apply21 (a b (a b -> c) -> c)
def apply21:
  __apply21

decl bottom ([a] -> a)
def bottom:
  __bottom

decl compose ((a -> b) (b -> c) -> (a -> c))
def compose:
  -> g
  -> f
  { f apply11 g apply11 }

decl --. (Float -> Float)
def --.:
  __dec_float

decl -- (Int -> Int)
def --:
  __dec_int

decl drop (a ->)
def drop:
  __drop

decl dup (a -> a a)
def dup:
  __dup

decl /. (Float Float -> Float)
def /.:
  __div_float

decl / (Int Int -> Int)
def /:
  __div_int

decl down ([a] -> [a])
def down:
  __down

decl =^ (Char Char -> Bool)
def =^:
  __eq_char

decl =. (Float Float -> Bool)
def =.:
  __eq_float

decl = (Int Int -> Bool)
def =:
  __eq_int

decl =* ([a] [a] -> Bool)
def =*:
  __eq_vector

decl empty ([a] -> Bool)
def empty:
  __empty

decl function (a -> (-> a))
def function:
  __function

decl >=^ (Char Char -> Bool)
def >=^:
  __ge_char

decl >=. (Float Float -> Bool)
def >=.:
  __ge_float

decl >= (Int Int -> Bool)
def >=:
  __ge_int

decl >=* ([a] [a] -> Bool)
def >=*:
  __ge_vector

decl get ([a] Int -> a)
def get:
  __get

decl >^ (Char Char -> Bool)
def >^:
  __gt_char

decl >. (Float Float -> Bool)
def >.:
  __gt_float

decl > (Int Int -> Bool)
def >:
  __gt_int

decl >* ([a] [a] -> Bool)
def >*:
  __gt_vector

decl ++. (Float -> Float)
def ++.:
  __inc_float

decl ++ (Int -> Int)
def ++:
  __inc_int

decl <=^ (Char Char -> Bool)
def <=^:
  __le_char

decl <=. (Float Float -> Bool)
def <=.:
  __le_float

decl <= (Int Int -> Bool)
def <=:
  __le_int

decl <=* ([a] [a] -> Bool)
def <=*:
  __le_vector

decl length ([a] -> Int)
def length:
  __length

decl <^ (Char Char -> Bool)
def <^:
  __lt_char

decl <. (Float Float -> Bool)
def <.:
  __lt_float

decl < (Int Int -> Bool)
def <:
  __lt_int

decl <* ([a] [a] -> Bool)
def <*:
  __lt_vector

decl %. (Float Float -> Float)
def %.:
  __mod_float

decl % (Int Int -> Int)
def %:
  __mod_int

decl *. (Float Float -> Float)
def *.:
  __mul_float

decl * (Int Int -> Int)
def *:
  __mul_int

decl !=^ (Char Char -> Bool)
def !=^:
  __ne_char

decl !=. (Float Float -> Bool)
def !=.:
  __ne_float

decl != (Int Int -> Bool)
def !=:
  __ne_int

decl !=* ([a] [a] -> Bool)
def !=*:
  __ne_vector

decl negf (Float -> Float)
def negf:
  __neg_float

decl negi (Int -> Int)
def negi:
  __neg_int

decl ! (Bool -> Bool)
def !:
  __not_bool

decl ~ (Int -> Int)
def ~:
  __not_int

decl || (Bool Bool -> Bool)
def ||:
  __or_bool

decl | (Int Int -> Int)
def |:
  __or_int

decl set ([a] a Int -> [a])
def set:
  __set

decl -. (Float Float -> Float)
def -.:
  __sub_float

decl - (Int Int -> Int)
def -:
  __sub_int

decl swap (a b -> b a)
def swap:
  __swap

decl top ([a] -> a)
def top:
  __top

decl up ([a] -> [a])
def up:
  __up

decl vector (a -> [a])
def vector:
  __vector

decl ^^ (Bool Bool -> Bool)
def ^^:
  __xor_bool

decl ^ (Int Int -> Int)
def ^:
  __xor_int

// Core

decl id (a -> a)
def id:
  -> x
  x

// Pushes a value to the top of a vector.
decl push ([a] a -> [a])
def push:
  vector +*

// Prepends a value to the bottom of a vector.
decl prepend (a [a] -> [a])
def prepend:
  -> xs
  -> x
  x vector xs +*

// def first ((a,) -> a):
//   __first
// 
// def second ((a, b) -> b):
//   __rest __first
// 
// def third ((a, b, c) -> c):
//   __rest __rest __first
// 
// def fourth ((a, b, c, d) -> d):
//   __rest __rest __rest __first

// Show

decl showb (Bool -> [Char])
def showb:
  if { "true" }
  else { "false" }

decl showi (Int -> [Char])
def showi:
  __show_int

decl showf (Float -> [Char])
def showf:
  __show_float

decl showbv ([Bool] -> [Char])
def showbv:
  \showb showv

decl showiv ([Int] -> [Char])
def showiv:
  \showi showv

decl showfv ([Float] -> [Char])
def showfv:
  \showf showv

decl showcvv ([[Char]] -> [Char])
def showcvv:
  \id showv

decl showv ([a] (a -> [Char]) -> [Char])
def showv:
  -> show
  -> xs
  "[ "
  xs "" {
    -> acc
    -> value
    value show apply11 " " +*
    acc +*
  } foldUp +*
  "]" +*

// Impure

decl handleClose (Handle ->)
def handleClose:
  __close

decl handleGetLine (Handle -> [Char])
def handleGetLine:
  __get_line

decl handlePrint ([Char] Handle ->)
def handlePrint:
  __print

decl getLine (-> [Char])
def getLine:
  stdin __get_line

decl openInput ([Char] -> Handle)
def openInput:
  __open_in

decl openOutput ([Char] -> Handle)
def openOutput:
  __open_out

decl stderr (Handle)
def stderr:
  __stderr

decl stdin (Handle)
def stdin:
  __stdin

decl stdout (Handle)
def stdout:
  __stdout

// Maps an impure function over each element of a vector.
decl each ([a] (a ->) ->)
def each:
  -> f
  { dup f apply10 } map
  drop

decl newline (->)
def newline:
  "\n" print

decl print ([Char] ->)
def print:
  stdout __print

decl printb (Bool ->)
def printb:
  showb print

decl printbv ([Bool] ->)
def printbv:
  showbv print

decl printf (Float ->)
def printf:
  showf print

decl printfv ([Float] ->)
def printfv:
  showfv print

decl printi (Int ->)
def printi:
  showi print

decl printiv ([Int] ->)
def printiv:
  showiv print

decl printcvv ([[Char]] ->)
def printcvv:
  showcvv print

decl say ([Char] ->)
def say:
  print newline

decl sayb (Bool ->)
def sayb:
  printb newline

decl saybv ([Bool] ->)
def saybv:
  printbv newline

decl sayf (Float ->)
def sayf:
  printf newline

decl sayfv ([Float] ->)
def sayfv:
  printfv newline

decl sayi (Int ->)
def sayi:
  printi newline

decl sayiv ([Int] ->)
def sayiv:
  printiv newline

decl saycvv ([[Char]] ->)
def saycvv:
  printcvv newline

decl space (->)
def space:
  " " print

// Math and Logic

decl and ([Bool] -> Bool)
def and:
  true \&& foldUp

decl eveni (Int -> Bool)
def eveni:
  2 __mod_int 0 __eq_int

decl evenf (Float -> Bool)
def evenf:
  2.0 %. 0.0 =.

decl max2 (Int Int -> Int)
def max2:
  -> a
  -> b
  if a b > : a else: b

decl max3 (Int Int Int -> Int)
def max3:
  max2 max2

decl min2 (Int Int -> Int)
def min2:
  -> a
  -> b
  if a b < : a else: b

decl min3 (Int Int Int -> Int)
def min3:
  min2 min2

decl oddi (Int -> Bool)
def oddi:
  eveni !

decl oddf (Float -> Bool)
def oddf:
  evenf !

decl or ([Bool] -> Bool)
def or:
  false \|| foldUp

decl producti ([Int] -> Int)
def producti:
  1 \* foldUp

decl productf ([Float] -> Float)
def productf:
  1.0 \*. foldUp

decl sumi ([Int] -> Int)
def sumi:
  0 \+ foldUp

decl sumf ([Float] -> Float)
def sumf:
  0.0 \+. foldUp

// Iterates a function on a value until a predicate holds.
decl until (a (a -> a) (a -> Bool) -> a)
def until:
  -> p
  -> f
  -> x
  if x p apply11:
    x
  else:
    x f apply11
    f p until

// Vector

// Folds elements of a vector bottom-up.
decl foldUp ([a] b (a b -> b) -> b)
def foldUp:
  -> k
  -> z
  -> xs
  if xs empty:
    z
  else:
    xs bottom
    xs up z k foldUp
    k apply21

// Folds elements of a vector top-down.
decl foldDown ([a] b (b a -> b) -> b)
def foldDown:
  -> k
  -> z
  -> xs
  if xs empty:
    z
  else:
    xs down z k foldDown
    xs top
    k apply21

// Filters a vector by a predicate.
decl filter ([a] (a -> Bool) -> [a])
def filter:
  -> f
  -> v
  if v empty:
    v
  else if v bottom f apply11:
    v bottom vector
    v up f filter
    +*
  else:
    v up f filter

// Gets a value from a 2D vector.
decl get2 ([[a]] Int Int -> a)
def get2:
  -> j
  -> i
  i get j get

// Keeps the topmost n elements of a vector, tossing the rest.
decl keep ([a] Int -> [a])
def keep:
  -> n
  -> xs
  if n 0 <=  xs empty  || :
    []
  else:
    xs down n-- keep
    xs top push

// Maps a function downward over the elements of a vector.
decl map ([a] (a -> b) -> [b])
def map:
  0 mapFrom

// Maps a function over part of a vector.
decl mapFrom ([a] (a -> b) Int -> [b])
def mapFrom:
  -> offset
  -> function
  -> vec
  if vec empty  offset vec length >=  || :
    vec
  else:
    vec function offset modify
    function offset++ mapFrom

// Maps a function over a value for each integer in a range.
decl mapRange (a (a Int -> a) Int Int -> a)
def mapRange:
  -> end
  -> start
  -> function
  -> value
  if start end <= :
    value start function apply21
    function start++ end mapRange
  else:
    value

// Maps a function over an element of a vector.
decl modify ([a] (a -> a) Int -> [a])
def modify:
  -> offset
  -> function
  -> vec
  vec offset get function apply11 -> value
  vec value offset set

// Produces a vector with some number of copies of a value.
decl replicate (a Int -> [a])
def replicate:
  -> count
  -> value
  if count 0 <= :
    []
  else:
    value vector
    value count-- replicate
    +*

// Sets a value in a 2D vector.
decl set2 ([[a]] a Int Int -> [[a]])
def set2:
  -> j
  -> i
  -> x
  { x j set } i modify

// Splits a vector at the given index.
decl split_at ([a] Int -> [a] [a])
def split_at:
  -> n
  -> xs
  xs n toss
  xs n keep

// Tosses the first n elements of a vector, keeping the rest.
decl toss ([a] Int -> [a])
def toss:
  -> n
  -> xs
  if n 0 <=  xs empty  || :
    xs
  else:
    xs down n-- toss
